

## Slices 切片

### 一、切片与数组

请先了解一哈数组~

一般创建并初始化数组，指定长度或让编译器自行计算

```go
a := [2]int{1, 2}
b := [...]int{1, 3, 4}
```

**切片简单来说就是不指定长度的增强版数组**

切片的类型写法为 []T，T为数据类型，切片没有具体长度。

切片的写法和数组大体相似，只是**不指定**元素个数。

```go
c := []int{1, 2, 4}
```

此外，切片一般使用内置函数**make**进行创建

```go
func make([] T, len, cap) []T
```

其中T表示元素类型，len表示长度，cap表示容量。调用make，底层会分配一个数组，然后返回数组对应的切片。**当cap和len相同时，可以省略cap参数。**

可以使用**len()**和**cap()**函数来返回切片的长度和容量。

切片的零值为**nil**，len和cap都会返回0

***

### 二、切片分割

通过现有的切片可以生成新的切片，切分范围为左闭右开。

```go
b := []byte{'h', 'e', 'l', 'l', 'o'}
b[1:4] == []byte{'e', 'l', 'l'}
//数组从0计数，则1:4表示第二个（左闭）到第四个（右开）. [1 , 4)
```

且切片的开始与结束都可省略

```go
b[:2] == []byte{'h', 'e'}
b[3:] == []byte{'l', 'o'}
b[:] == b 
s := b[:] //切片引用数组的内存区域
```

**注：切片分割操作本质是引用**

***

### 三、内部实现

![内存结构](https://img-blog.csdnimg.cn/20190408183138215.png)

切片包含了指向数组的指针，片段长度和容量（片段最大长度）

如上图，创建一个长度为5的byte类型的切片

```go
s := []byte{'a', 'b', 'c', 'd', 'e'}
```

此时cap = len = 5 ，数据存储在连续的五块内存中

此时做切片分割，分割[2:4] 即定义s1切片引用，为s[2]与s[3]

此时可见，cap(s1) = 3, len(s1) = 2。

因为s1为对s的引用，虽然len长度为2，但在原先s创建时cap为5，在s1进行引用的时候，实际上cap包含了s[3]之后的s[4]。但在s1中无法访问s[4]，因为分割长度为2，s1中仅保存s[2]s[3]，调用s[4]会越界错误。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190408183152695.png)

此时若再对s1进行切片分割为s2，则可以[:3]，即切片分割是分割cap而不是len

此时s2为s的[2:5]

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190408183210687.png)

***

### 四、切片增长

增长切片本质上是创建一个新的，容量更大的切片，然后复制原切片到新切片。

#### 1、copy

复制操作可以使用copy代替，copy函数将源切片复制到目的切片，返回元素数目

```go
func copy(dst, src []T) int
```

```go
s := []int{1, 2, 3, 4}
t := make([]int, 10, 10)
copy(t, s)
```

如上，将s中的元素通过copy拷贝到t中

#### 2、append

使用append执行追加

```go
s := []int{1, 2, 3, 4}
s := append(s, 5, 6)
```

#### 3、一些小问题~

由内部实现可知，切片创建的时候cap会默认包含后续数据，即虽然切片len很小，但由于指针指向大片数据，导致少量的有用信息占用大量内存，此时可以新建切片进行拷贝。